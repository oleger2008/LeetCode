/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        auto *cur = node; // 5
        while (cur->next->next) { // 9
            std::swap(cur->val, cur->next->val); 
            cur = cur->next; // 5
        }
        std::swap(cur->val, cur->next->val); 
        cur->next = nullptr;
    }
};

// под удаление ноды не имеется в виду удаление из памяти
// есть гарания что нода существует в поданном листе
// нода для удаления не является ластовой !!!!!!!!!!!!!!!!!!!!!!!!!
// на вход не дают голову. только ноду кот надо удалить
// число нод: от 2 до 1000
// значение ноды: от -1000 до 1000
// значение ноды уникально
// важно сохранить порядок

// обычно чтобы удалить ноду, мне нужно предыдущая нода и следующая
// у предыдущей сделать некст на после следующую и все

// посмотреть краевоей случай с 2 нодами
// 1 -> 2
// input: 1 - занулить next
// result: 2

// решение: кажется можно просто перебить все значения и отвязать последний узел
// время:  O(N)
// mem: O(1)

//      c
// 4 -> 5 -> 1 -> 9

//      c
// 4 -> 1 -> 5 -> 9

//           c
// 4 -> 1 -> 5 -> 9 -> null

//           c
// 4 -> 1 -> 9 -> 5 -> null
//           c
// 4 -> 1 -> 9 -> null

//----

// 1 -> 2 -> null
